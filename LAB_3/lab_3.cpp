//Васильев Никита МОАИС Б9122-02.03.03тп, лаба 3
//Демонстрация паттерна "Factory Method"
#include <iostream>
#include <string>

// Класс "Компьютер"
class Computer {
private:
    std::string model;
    int price;

public:
    Computer(const std::string& model, int price) : model(model), price(price) {}

    void info() const {
        std::cout << "Model: " << model << ", Price: $" << price << std::endl;
    }
};

// Класс "Мышь"
class Mouse {
private:
    std::string brand;
    std::string type;

public:
    Mouse(const std::string& brand, const std::string& type) : brand(brand), type(type) {}

    void info() const {
        std::cout << "Brand: " << brand << ", Type: " << type << std::endl;
    }
};

// Фабрика для производства компьютеров и мышей
class Factory {
public:
    static Computer createComputer(const std::string& model, int price) {
        return Computer(model, price);
    }

    static Mouse createMouse(const std::string& brand, const std::string& type) {
        return Mouse(brand, type);
    }
};

int main() {
    // Создаем компьютер с помощью фабрики
    Computer computer = Factory::createComputer("Lenovo", 1000);
    computer.info();

    // Создаем мышь с помощью фабрики
    Mouse mouse = Factory::createMouse("Logitech", "Wireless");
    mouse.info();

    return 0;
}


//Паттерн "Фабричный метод" на C++ решает следующие задачи:

//Изолирует клиентский код от конкретных классов продуктов, позволяя ему работать только с абстрактным интерфейсом продукта. Клиентский код, использующий фабричный метод, не зависит от конкретных реализаций продуктов, что упрощает расширение и поддержку кода.

//Обеспечивает гибкость в создании объектов. Фабричный метод предоставляет общий интерфейс для создания объектов, при этом позволяет каждому подклассу решать, какой именно объект необходимо создавать. Это упрощает добавление новых видов продуктов без изменения существующего кода.

//Поддерживает принцип инверсии зависимости. Клиентский код зависит от абстрактного интерфейса создателя и продукта, а не от конкретных классов продуктов или создателей. Это позволяет создавать более слабосвязанные системы и упрощает тестирование и модификацию кода.

//Повышает расширяемость кода. При добавлении новых классов продуктов или создателей не требуется изменять существующий клиентский код. Достаточно создать новый подкласс создателя и продукта, реализующий требуемую функциональность.

//Позволяет управлять процессом создания объектов в одном месте. Фабричный метод централизует процесс создания объектов внутри классов создателей, что может быть полезным, например, при внедрении зависимостей или при контроле над процессом инстанцирования.